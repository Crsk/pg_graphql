{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pg_graphql Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql Query your existing PostgreSQL database with GraphQL pg_graphql inspects your PostgreSQL schema and reflects a GraphQL schema with resolvers. Performant : +2k requests/second Always up-to-date : Reflected from the SQL schema Pagination : Relay compliant Serverless : Runs in your database with no additional server required Open Source : Apache License 2.0 Warning pg_graphql is pre-alpha software under active development Motivation pg_graphql provides an SQL schema -> GraphQL schema reflection engine and an associated GraphQL query -> SQL query transpiler. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries. TL;DR The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- Turn on automatic inflection of type names comment on schema public is '@graphql({\"inflect_names\": true})' ; create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); -- enable a `totalCount` field on the `account` query type comment on table account is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema exposing each table as a pageable collection with relationships defined by the foreign keys.","title":"Welcome"},{"location":"#pg_graphql","text":"Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql Query your existing PostgreSQL database with GraphQL pg_graphql inspects your PostgreSQL schema and reflects a GraphQL schema with resolvers. Performant : +2k requests/second Always up-to-date : Reflected from the SQL schema Pagination : Relay compliant Serverless : Runs in your database with no additional server required Open Source : Apache License 2.0 Warning pg_graphql is pre-alpha software under active development","title":"pg_graphql"},{"location":"#motivation","text":"pg_graphql provides an SQL schema -> GraphQL schema reflection engine and an associated GraphQL query -> SQL query transpiler. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries.","title":"Motivation"},{"location":"#tldr","text":"The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- Turn on automatic inflection of type names comment on schema public is '@graphql({\"inflect_names\": true})' ; create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); -- enable a `totalCount` field on the `account` query type comment on table account is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema exposing each table as a pageable collection with relationships defined by the foreign keys.","title":"TL;DR"},{"location":"api/","text":"The public API consists of a single function to resolve GraphQL queries. All other entities in the graphql schema are private. graphql.resolve description Resolves a GraphQL query, returning JSONB. signature 1 2 3 4 5 6 7 8 9 10 11 12 graphql . resolve ( -- the graphql query/mutation stmt text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , ) returns jsonb strict volatile parallel safe language plpgsql usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- Setup graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Example graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"API"},{"location":"api/#graphqlresolve","text":"","title":"graphql.resolve"},{"location":"api/#description","text":"Resolves a GraphQL query, returning JSONB.","title":"description"},{"location":"api/#signature","text":"1 2 3 4 5 6 7 8 9 10 11 12 graphql . resolve ( -- the graphql query/mutation stmt text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , ) returns jsonb strict volatile parallel safe language plpgsql","title":"signature"},{"location":"api/#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- Setup graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Example graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"usage"},{"location":"computed_fields/","text":"PostgreSQL Builtin PostgreSQL has a builtin feature for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the reccomended approach to adding computed fields when your computation meets the restrictions. The most significant restrictions of generated columns are: expression must be immutable expression may only reference the current row For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , full_name text generated always as ( first_name || ' ' || last_name ) stored ); insert into public . account ( first_name , last_name ) values ( 'Foo' , 'Fooington' ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName } } } } $$ ) ); jsonb_pretty ------------------------------------------------------ { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ; Extending Types with Functions For arbitrary computations that do not meet the requirements for generated columns , a table's reflected GraphQL type can be extended by creating a function that: accepts a single parameter of the table's tuple type has a name starting with an underscore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , parent_id int references account ( id ) ); -- Extend with function create function public . \"_fullName\" ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; insert into public . account ( first_name , last_name , parent_id ) values ( 'Foo' , 'Fooington' , 1 ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName parent { fullName } } } } } $$ ) ); jsonb_pretty --------------------------------------------------------- { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"parent\" : { + \"fullName\" : \"Foo Fooington\" + } , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ;","title":"Computed Fields"},{"location":"computed_fields/#postgresql-builtin","text":"PostgreSQL has a builtin feature for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the reccomended approach to adding computed fields when your computation meets the restrictions. The most significant restrictions of generated columns are: expression must be immutable expression may only reference the current row For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , full_name text generated always as ( first_name || ' ' || last_name ) stored ); insert into public . account ( first_name , last_name ) values ( 'Foo' , 'Fooington' ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName } } } } $$ ) ); jsonb_pretty ------------------------------------------------------ { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ;","title":"PostgreSQL Builtin"},{"location":"computed_fields/#extending-types-with-functions","text":"For arbitrary computations that do not meet the requirements for generated columns , a table's reflected GraphQL type can be extended by creating a function that: accepts a single parameter of the table's tuple type has a name starting with an underscore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , parent_id int references account ( id ) ); -- Extend with function create function public . \"_fullName\" ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; insert into public . account ( first_name , last_name , parent_id ) values ( 'Foo' , 'Fooington' , 1 ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName parent { fullName } } } } } $$ ) ); jsonb_pretty --------------------------------------------------------- { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"parent\" : { + \"fullName\" : \"Foo Fooington\" + } , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ;","title":"Extending Types with Functions"},{"location":"configuration/","text":"Table/Column Visibility Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL permissions. Revoking SELECT access from the user/role executing queries removes that entity from the visible schema. For example: 1 revoke all privileges on public . \"Account\" from api_user ; removes the Account GraphQL type. Similarly, revoking SELECT access on a table's column will remove that field from the associated GraphQL type/s. The permissions SELECT , INSERT , UPDATE , and DELETE all impact the relevant sections of the GraphQL schema. Row Visibilty Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies. Comment Directives Comment directives are snippets of configuration associated with SQL entities that alter if/how those entities are reflected into the GraphQL schema. The format of a comment directive is 1 @ graphql ( < JSON > ) Inflection Inflection describes how SQL entities' names are transformed into GraphQL type and field names. By default, inflection is disabled and SQL names are literally interpolated such that 1 2 3 4 create table \"BlogPost\" ( id int primary key , ... ); results in GraphQL type names like 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... Since snake case is a common casing structure for SQL types, pg_graphql support basic inflection from snake_case to PascalCase for type names, and snake_case to camelCase for field names to match Javascript conventions. The inflection directive is applied at the schema level and can be enable with: 1 comment on schema < schema_name > is e '@graphql({\"inflect_names\": true})' ; for example 1 2 3 4 5 6 comment on schema public is e '@graphql({\"inflect_names\": true})' ; create table blog_post ( id int primary key , ... ); similarly would generated the GraphQL type names 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... For more fine grained adjustments to reflected names, see renaming . totalCount totalCount is an opt-in field that is applied to each query type. It provides a count of the rows that match the query's filters, and ignores pagination arguments. 1 2 3 4 5 6 7 type BlogPostConnection { edges : [BlogPostEdge ! ] ! pageInfo : PageInfo ! \"\"\"The total number of records matching the `filter` criteria\"\"\" totalCount : Int ! # this field } to enable totalCount for a table, use the directive 1 comment on table blog_post is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; for example 1 2 3 4 5 create table \"BlogPost\" ( id serial primary key , email varchar ( 255 ) not null ); comment on table \"BlogPost\" is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; Renaming Table's Type Use the \"name\" JSON key to override a table's type name. 1 2 3 4 5 6 create table account ( id serial primary key ); comment on table public . account is e '@graphql({\"name\": \"AccountHolder\"})' ; results in: 1 2 3 type AccountHolder { # previously: \"Account\" id : Int ! } Column's Field Name Use the \"name\" JSON key to override a column's field name. 1 2 3 4 5 6 7 create table public . \"Account\" ( id serial primary key , email text ); comment on column \"Account\" . email is e '@graphql({\"name\": \"emailAddress\"})' ; results in: 1 2 3 4 type Account { id : Int ! emailAddress : String ! # previously \"email\" } Computed Field Use the \"name\" JSON key to override a computed field's name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table \"Account\" ( id serial primary key , \"firstName\" varchar ( 255 ) not null , \"lastName\" varchar ( 255 ) not null ); -- Extend with function create function public . \"_fullName\" ( rec public . \"Account\" ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . \"firstName\" , rec . \"lastName\" ) $$ ; comment on function public . _full_name is e '@graphql({\"name\": \"displayName\"})' ; results in: 1 2 3 4 5 6 type Account { id : Int ! firstName : String ! lastName : String ! displayName : String # previously \"fullName\" } Relationship's Field Use the \"local_name\" and \"foreign_name\" JSON keys to override a a relationships inbound and outbound field names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create table \"Account\" ( id serial primary key ); create table \"Post\" ( id serial primary key , \"accountId\" integer not null references \"Account\" ( id ), title text not null , body text ); comment on constraint post_owner_id_fkey on post is E '@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})' ; results in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Post { id : Int ! accountId : Int ! title : String ! body : String ! author : Account # was \"account\" } type Account { id : Int ! posts ( # was \"postCollection\" after : Cursor , before : Cursor , filter : PostFilter , first : Int , last : Int , orderBy : [PostOrderBy ! ] ) : PostConnection }","title":"Configuration"},{"location":"configuration/#tablecolumn-visibility","text":"Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL permissions. Revoking SELECT access from the user/role executing queries removes that entity from the visible schema. For example: 1 revoke all privileges on public . \"Account\" from api_user ; removes the Account GraphQL type. Similarly, revoking SELECT access on a table's column will remove that field from the associated GraphQL type/s. The permissions SELECT , INSERT , UPDATE , and DELETE all impact the relevant sections of the GraphQL schema.","title":"Table/Column Visibility"},{"location":"configuration/#row-visibilty","text":"Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies.","title":"Row Visibilty"},{"location":"configuration/#comment-directives","text":"Comment directives are snippets of configuration associated with SQL entities that alter if/how those entities are reflected into the GraphQL schema. The format of a comment directive is 1 @ graphql ( < JSON > )","title":"Comment Directives"},{"location":"configuration/#inflection","text":"Inflection describes how SQL entities' names are transformed into GraphQL type and field names. By default, inflection is disabled and SQL names are literally interpolated such that 1 2 3 4 create table \"BlogPost\" ( id int primary key , ... ); results in GraphQL type names like 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... Since snake case is a common casing structure for SQL types, pg_graphql support basic inflection from snake_case to PascalCase for type names, and snake_case to camelCase for field names to match Javascript conventions. The inflection directive is applied at the schema level and can be enable with: 1 comment on schema < schema_name > is e '@graphql({\"inflect_names\": true})' ; for example 1 2 3 4 5 6 comment on schema public is e '@graphql({\"inflect_names\": true})' ; create table blog_post ( id int primary key , ... ); similarly would generated the GraphQL type names 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... For more fine grained adjustments to reflected names, see renaming .","title":"Inflection"},{"location":"configuration/#totalcount","text":"totalCount is an opt-in field that is applied to each query type. It provides a count of the rows that match the query's filters, and ignores pagination arguments. 1 2 3 4 5 6 7 type BlogPostConnection { edges : [BlogPostEdge ! ] ! pageInfo : PageInfo ! \"\"\"The total number of records matching the `filter` criteria\"\"\" totalCount : Int ! # this field } to enable totalCount for a table, use the directive 1 comment on table blog_post is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; for example 1 2 3 4 5 create table \"BlogPost\" ( id serial primary key , email varchar ( 255 ) not null ); comment on table \"BlogPost\" is e '@graphql({\"totalCount\": {\"enabled\": true}})' ;","title":"totalCount"},{"location":"configuration/#renaming","text":"","title":"Renaming"},{"location":"configuration/#tables-type","text":"Use the \"name\" JSON key to override a table's type name. 1 2 3 4 5 6 create table account ( id serial primary key ); comment on table public . account is e '@graphql({\"name\": \"AccountHolder\"})' ; results in: 1 2 3 type AccountHolder { # previously: \"Account\" id : Int ! }","title":"Table's Type"},{"location":"configuration/#columns-field-name","text":"Use the \"name\" JSON key to override a column's field name. 1 2 3 4 5 6 7 create table public . \"Account\" ( id serial primary key , email text ); comment on column \"Account\" . email is e '@graphql({\"name\": \"emailAddress\"})' ; results in: 1 2 3 4 type Account { id : Int ! emailAddress : String ! # previously \"email\" }","title":"Column's Field Name"},{"location":"configuration/#computed-field","text":"Use the \"name\" JSON key to override a computed field's name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table \"Account\" ( id serial primary key , \"firstName\" varchar ( 255 ) not null , \"lastName\" varchar ( 255 ) not null ); -- Extend with function create function public . \"_fullName\" ( rec public . \"Account\" ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . \"firstName\" , rec . \"lastName\" ) $$ ; comment on function public . _full_name is e '@graphql({\"name\": \"displayName\"})' ; results in: 1 2 3 4 5 6 type Account { id : Int ! firstName : String ! lastName : String ! displayName : String # previously \"fullName\" }","title":"Computed Field"},{"location":"configuration/#relationships-field","text":"Use the \"local_name\" and \"foreign_name\" JSON keys to override a a relationships inbound and outbound field names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create table \"Account\" ( id serial primary key ); create table \"Post\" ( id serial primary key , \"accountId\" integer not null references \"Account\" ( id ), title text not null , body text ); comment on constraint post_owner_id_fkey on post is E '@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})' ; results in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Post { id : Int ! accountId : Int ! title : String ! body : String ! author : Account # was \"account\" } type Account { id : Int ! posts ( # was \"postCollection\" after : Cursor , before : Cursor , filter : PostFilter , first : Int , last : Int , orderBy : [PostOrderBy ! ] ) : PostConnection }","title":"Relationship's Field"},{"location":"contributing/","text":"pg_graphql is OSS. PR and issues are welcome. Development Nix is required to set up the environment. Testing Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 2 # might take a few minutes downloading dependencies on the first run $ nix-shell --run \"pg_13_graphql make installcheck\" Interactive PSQL Development To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 nix-shell --run \"pg_13_graphql psql\" Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] } Documentation All public API must be documented. Building documentation requires python 3.6+ Install Dependencies Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt Serving To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Contributing"},{"location":"contributing/#development","text":"Nix is required to set up the environment.","title":"Development"},{"location":"contributing/#testing","text":"Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 2 # might take a few minutes downloading dependencies on the first run $ nix-shell --run \"pg_13_graphql make installcheck\"","title":"Testing"},{"location":"contributing/#interactive-psql-development","text":"To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 nix-shell --run \"pg_13_graphql psql\" Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"Interactive PSQL Development"},{"location":"contributing/#documentation","text":"All public API must be documented. Building documentation requires python 3.6+","title":"Documentation"},{"location":"contributing/#install-dependencies","text":"Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt","title":"Install Dependencies"},{"location":"contributing/#serving","text":"To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Serving"},{"location":"installation/","text":"Tested with PostgreSQL 13. Direct Server Access First, install libgraphqlparser Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql make install To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql cascade ; Hosted Databases e.g. RDS, Cloud SQL Hosted database vendors do not provide the level of server access required to install pg_graphql at this time. Given that third-party hosted databases are increasingly common, we are exploring including SQL implementations of pg_graphql 's C components so it can be installed as a single-file SQL script. Stay tuned","title":"Installation"},{"location":"installation/#direct-server-access","text":"First, install libgraphqlparser Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql make install To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql cascade ;","title":"Direct Server Access"},{"location":"installation/#hosted-databases-eg-rds-cloud-sql","text":"Hosted database vendors do not provide the level of server access required to install pg_graphql at this time. Given that third-party hosted databases are increasingly common, we are exploring including SQL implementations of pg_graphql 's C components so it can be installed as a single-file SQL script. Stay tuned","title":"Hosted Databases e.g. RDS, Cloud SQL"},{"location":"performance/","text":"On a machine with: 4 CPUs 16GB of RAM PostgreSQL 14 (docker) Postgrest +9 (docker, operating as webserver) pg_graphql served a simple query at an average rate of +2200 req/second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 This is ApacheBench, Version 2.3 <$Revision: 1843412 $> Benchmarking 0.0.0.0 (be patient) Finished 8000 requests Server Software: postgrest/8.0.0 Server Hostname: 0.0.0.0 Server Port: 3000 Document Path: /rpc/graphql Document Length: 46 bytes Concurrency Level: 8 Time taken for tests: 3.628 seconds Complete requests: 8000 Failed requests: 0 Total transferred: 1768000 bytes Total body sent: 1928000 HTML transferred: 368000 bytes Requests per second: 2205.21 [#/sec] (mean) Time per request: 3.628 [ms] (mean) Time per request: 0.453 [ms] (mean, across all concurrent requests) Transfer rate: 475.93 [Kbytes/sec] received 519.00 kb/s sent 994.93 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 1 4 3.7 2 39 Waiting: 0 3 3.6 2 39 Total: 1 4 3.7 2 39 Percentage of the requests served within a certain time (ms) 50% 2 66% 3 75% 3 80% 4 90% 7 95% 10 98% 15 99% 22 100% 39 (longest request) To reproduce this result, start the demo described in the quickstart guide and apache bench on a sample query. i.e. 1 2 3 4 5 docker-compose up echo '{\"query\": \"{ accountCollection(first: 1) { edges { node { id } } } }\", \"variables\": {}}' > query.json ab -n 8000 -c 8 -T application/json -p query.json http://0.0.0.0:3000/rpc/graphql","title":"Performance"},{"location":"quickstart/","text":"If you are new to the project, start here. The easiest way to try pg_graphql is to run the interactive GraphiQL IDE demo. The demo environment launches a database, webserver and the GraphiQL IDE/API explorer with a small pre-populated schema. Requires: git docker-compose First, clone the repo 1 2 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql Next, launch the demo with docker-compose. 1 docker-compose up Finally, access GraphiQL at http://localhost:4000/ .","title":"Quickstart"},{"location":"reflection/","text":"SQL tables are reflected into GraphQL types with columns and foreign keys represented as fields on those types. Naming By default, PostgreSQL table and column names are not adjusted when reflecting GraphQL type and field names. For example, an account_holder table has GraphQL type name account_holder and can be queried via the account_holderCollection field of the Query type. In cases, like the previous example, where the SQL name is snake_case , you may want to enable inflection so types are reflected as AccountHolder and accountHolderCollection . Table, column, and relationship type and field names may also be manually overridden as needed. Type Conversion Connection Types Connection types hande pagination best practices according to the relay spec . pg_graphql paginates via keyset pagination to enable consistent retrival times on every page. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- Turn on automatic inflection of type names comment on schema public is '@graphql({\"inflect_names\": true})' ; create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); -- enable a `totalCount` field on the `account` query type comment on table account is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 type Account { id : Int ! email : String ! encryptedPassword : String ! createdAt : DateTime ! updatedAt : DateTime ! blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogOrderBy ! ] ) : BlogConnection } type AccountConnection { edges : [AccountEdge ! ] ! pageInfo : PageInfo ! \"\"\"The total number of records matching the `filter` criteria\"\"\" totalCount : Int ! } type AccountDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Account ! ] ! } type AccountEdge { cursor : String ! node : Account } input AccountFilter { id : IntFilter email : StringFilter encryptedPassword : StringFilter createdAt : DateTimeFilter updatedAt : DateTimeFilter } input AccountInsertInput { email : String encryptedPassword : String createdAt : DateTime updatedAt : DateTime } type AccountInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Account ! ] ! } input AccountOrderBy { id : OrderByDirection email : OrderByDirection encryptedPassword : OrderByDirection createdAt : OrderByDirection updatedAt : OrderByDirection } input AccountUpdateInput { email : String encryptedPassword : String createdAt : DateTime updatedAt : DateTime } type AccountUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Account ! ] ! } scalar BigInt \"\"\" Boolean expression comparing fields on type \" BigInt \" \"\"\" input BigIntFilter { eq : BigInt gt : BigInt gte : BigInt lt : BigInt lte : BigInt neq : BigInt } type Blog { id : Int ! ownerId : Int ! name : String ! description : String createdAt : DateTime ! updatedAt : DateTime ! blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogPostOrderBy ! ] ) : BlogPostConnection owner : Account } type BlogConnection { edges : [BlogEdge ! ] ! pageInfo : PageInfo ! } type BlogDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Blog ! ] ! } type BlogEdge { cursor : String ! node : Blog } input BlogFilter { id : IntFilter ownerId : IntFilter name : StringFilter description : StringFilter createdAt : DateTimeFilter updatedAt : DateTimeFilter } input BlogInsertInput { ownerId : Int name : String description : String createdAt : DateTime updatedAt : DateTime } type BlogInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Blog ! ] ! } input BlogOrderBy { id : OrderByDirection ownerId : OrderByDirection name : OrderByDirection description : OrderByDirection createdAt : OrderByDirection updatedAt : OrderByDirection } type BlogPost { id : UUID ! blogId : Int ! title : String ! body : String status : String ! createdAt : DateTime ! updatedAt : DateTime ! blog : Blog } type BlogPostConnection { edges : [BlogPostEdge ! ] ! pageInfo : PageInfo ! } type BlogPostDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [BlogPost ! ] ! } type BlogPostEdge { cursor : String ! node : BlogPost } input BlogPostFilter { id : UUIDFilter blogId : IntFilter title : StringFilter body : StringFilter status : StringFilter createdAt : DateTimeFilter updatedAt : DateTimeFilter } input BlogPostInsertInput { id : UUID blogId : Int title : String body : String status : String createdAt : DateTime updatedAt : DateTime } type BlogPostInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [BlogPost ! ] ! } input BlogPostOrderBy { id : OrderByDirection blogId : OrderByDirection title : OrderByDirection body : OrderByDirection status : OrderByDirection createdAt : OrderByDirection updatedAt : OrderByDirection } enum BlogPostStatus { PENDING RELEASED } input BlogPostUpdateInput { id : UUID blogId : Int title : String body : String status : String createdAt : DateTime updatedAt : DateTime } type BlogPostUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [BlogPost ! ] ! } input BlogUpdateInput { ownerId : Int name : String description : String createdAt : DateTime updatedAt : DateTime } type BlogUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Blog ! ] ! } \"\"\" Boolean expression comparing fields on type \" Boolean \" \"\"\" input BooleanFilter { eq : Boolean gt : Boolean gte : Boolean lt : Boolean lte : Boolean neq : Boolean } scalar Cursor scalar DateTime \"\"\" Boolean expression comparing fields on type \" DateTime \" \"\"\" input DateTimeFilter { eq : DateTime gt : DateTime gte : DateTime lt : DateTime lte : DateTime neq : DateTime } \"\"\" Boolean expression comparing fields on type \" Float \" \"\"\" input FloatFilter { eq : Float gt : Float gte : Float lt : Float lte : Float neq : Float } \"\"\" Boolean expression comparing fields on type \" Int \" \"\"\" input IntFilter { eq : Int gt : Int gte : Int lt : Int lte : Int neq : Int } scalar JSON \"\"\" Boolean expression comparing fields on type \" JSON \" \"\"\" input JSONFilter { eq : JSON neq : JSON } \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromAccountCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : AccountDeleteResponse ! \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogDeleteResponse ! \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogPostCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogPostDeleteResponse ! \"\"\"Adds one or more `AccountInsertResponse` records to the collection\"\"\" insertIntoAccountCollection ( objects : [AccountInsertInput ! ] ! ) : AccountInsertResponse \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\" insertIntoBlogCollection ( objects : [BlogInsertInput ! ] ! ) : BlogInsertResponse \"\"\"Adds one or more `BlogPostInsertResponse` records to the collection\"\"\" insertIntoBlogPostCollection ( objects : [BlogPostInsertInput ! ] ! ) : BlogPostInsertResponse \"\"\"Updates zero or more records in the collection\"\"\" updateAccountCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set : AccountUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : AccountUpdateResponse ! \"\"\"Updates zero or more records in the collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set : BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogUpdateResponse ! \"\"\"Updates zero or more records in the collection\"\"\" updateBlogPostCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set : BlogPostUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogPostUpdateResponse ! } \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { AscNullsFirst AscNullsLast DescNullsFirst DescNullsLast } type PageInfo { endCursor : String hasNextPage : Boolean ! hasPreviousPage : Boolean ! startCursor : String } \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Account`\"\"\" accountCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : AccountFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [AccountOrderBy ! ] ) : AccountConnection \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogOrderBy ! ] ) : BlogConnection \"\"\"A pagable collection of type `BlogPost`\"\"\" blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogPostOrderBy ! ] ) : BlogPostConnection } \"\"\" Boolean expression comparing fields on type \" String \" \"\"\" input StringFilter { eq : String gt : String gte : String lt : String lte : String neq : String } scalar UUID \"\"\" Boolean expression comparing fields on type \" UUID \" \"\"\" input UUIDFilter { eq : UUID neq : UUID }","title":"Reflection"},{"location":"reflection/#naming","text":"By default, PostgreSQL table and column names are not adjusted when reflecting GraphQL type and field names. For example, an account_holder table has GraphQL type name account_holder and can be queried via the account_holderCollection field of the Query type. In cases, like the previous example, where the SQL name is snake_case , you may want to enable inflection so types are reflected as AccountHolder and accountHolderCollection . Table, column, and relationship type and field names may also be manually overridden as needed.","title":"Naming"},{"location":"reflection/#type-conversion","text":"","title":"Type Conversion"},{"location":"reflection/#connection-types","text":"Connection types hande pagination best practices according to the relay spec . pg_graphql paginates via keyset pagination to enable consistent retrival times on every page.","title":"Connection Types"},{"location":"reflection/#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- Turn on automatic inflection of type names comment on schema public is '@graphql({\"inflect_names\": true})' ; create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); -- enable a `totalCount` field on the `account` query type comment on table account is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 type Account { id : Int ! email : String ! encryptedPassword : String ! createdAt : DateTime ! updatedAt : DateTime ! blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogOrderBy ! ] ) : BlogConnection } type AccountConnection { edges : [AccountEdge ! ] ! pageInfo : PageInfo ! \"\"\"The total number of records matching the `filter` criteria\"\"\" totalCount : Int ! } type AccountDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Account ! ] ! } type AccountEdge { cursor : String ! node : Account } input AccountFilter { id : IntFilter email : StringFilter encryptedPassword : StringFilter createdAt : DateTimeFilter updatedAt : DateTimeFilter } input AccountInsertInput { email : String encryptedPassword : String createdAt : DateTime updatedAt : DateTime } type AccountInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Account ! ] ! } input AccountOrderBy { id : OrderByDirection email : OrderByDirection encryptedPassword : OrderByDirection createdAt : OrderByDirection updatedAt : OrderByDirection } input AccountUpdateInput { email : String encryptedPassword : String createdAt : DateTime updatedAt : DateTime } type AccountUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Account ! ] ! } scalar BigInt \"\"\" Boolean expression comparing fields on type \" BigInt \" \"\"\" input BigIntFilter { eq : BigInt gt : BigInt gte : BigInt lt : BigInt lte : BigInt neq : BigInt } type Blog { id : Int ! ownerId : Int ! name : String ! description : String createdAt : DateTime ! updatedAt : DateTime ! blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogPostOrderBy ! ] ) : BlogPostConnection owner : Account } type BlogConnection { edges : [BlogEdge ! ] ! pageInfo : PageInfo ! } type BlogDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Blog ! ] ! } type BlogEdge { cursor : String ! node : Blog } input BlogFilter { id : IntFilter ownerId : IntFilter name : StringFilter description : StringFilter createdAt : DateTimeFilter updatedAt : DateTimeFilter } input BlogInsertInput { ownerId : Int name : String description : String createdAt : DateTime updatedAt : DateTime } type BlogInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Blog ! ] ! } input BlogOrderBy { id : OrderByDirection ownerId : OrderByDirection name : OrderByDirection description : OrderByDirection createdAt : OrderByDirection updatedAt : OrderByDirection } type BlogPost { id : UUID ! blogId : Int ! title : String ! body : String status : String ! createdAt : DateTime ! updatedAt : DateTime ! blog : Blog } type BlogPostConnection { edges : [BlogPostEdge ! ] ! pageInfo : PageInfo ! } type BlogPostDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [BlogPost ! ] ! } type BlogPostEdge { cursor : String ! node : BlogPost } input BlogPostFilter { id : UUIDFilter blogId : IntFilter title : StringFilter body : StringFilter status : StringFilter createdAt : DateTimeFilter updatedAt : DateTimeFilter } input BlogPostInsertInput { id : UUID blogId : Int title : String body : String status : String createdAt : DateTime updatedAt : DateTime } type BlogPostInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [BlogPost ! ] ! } input BlogPostOrderBy { id : OrderByDirection blogId : OrderByDirection title : OrderByDirection body : OrderByDirection status : OrderByDirection createdAt : OrderByDirection updatedAt : OrderByDirection } enum BlogPostStatus { PENDING RELEASED } input BlogPostUpdateInput { id : UUID blogId : Int title : String body : String status : String createdAt : DateTime updatedAt : DateTime } type BlogPostUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [BlogPost ! ] ! } input BlogUpdateInput { ownerId : Int name : String description : String createdAt : DateTime updatedAt : DateTime } type BlogUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount : Int ! \"\"\"Array of records impacted by the mutation\"\"\" records : [Blog ! ] ! } \"\"\" Boolean expression comparing fields on type \" Boolean \" \"\"\" input BooleanFilter { eq : Boolean gt : Boolean gte : Boolean lt : Boolean lte : Boolean neq : Boolean } scalar Cursor scalar DateTime \"\"\" Boolean expression comparing fields on type \" DateTime \" \"\"\" input DateTimeFilter { eq : DateTime gt : DateTime gte : DateTime lt : DateTime lte : DateTime neq : DateTime } \"\"\" Boolean expression comparing fields on type \" Float \" \"\"\" input FloatFilter { eq : Float gt : Float gte : Float lt : Float lte : Float neq : Float } \"\"\" Boolean expression comparing fields on type \" Int \" \"\"\" input IntFilter { eq : Int gt : Int gte : Int lt : Int lte : Int neq : Int } scalar JSON \"\"\" Boolean expression comparing fields on type \" JSON \" \"\"\" input JSONFilter { eq : JSON neq : JSON } \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromAccountCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : AccountDeleteResponse ! \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogDeleteResponse ! \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogPostCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogPostDeleteResponse ! \"\"\"Adds one or more `AccountInsertResponse` records to the collection\"\"\" insertIntoAccountCollection ( objects : [AccountInsertInput ! ] ! ) : AccountInsertResponse \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\" insertIntoBlogCollection ( objects : [BlogInsertInput ! ] ! ) : BlogInsertResponse \"\"\"Adds one or more `BlogPostInsertResponse` records to the collection\"\"\" insertIntoBlogPostCollection ( objects : [BlogPostInsertInput ! ] ! ) : BlogPostInsertResponse \"\"\"Updates zero or more records in the collection\"\"\" updateAccountCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set : AccountUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : AccountUpdateResponse ! \"\"\"Updates zero or more records in the collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set : BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogUpdateResponse ! \"\"\"Updates zero or more records in the collection\"\"\" updateBlogPostCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set : BlogPostUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter : BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost : Int ! = 1 ) : BlogPostUpdateResponse ! } \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { AscNullsFirst AscNullsLast DescNullsFirst DescNullsLast } type PageInfo { endCursor : String hasNextPage : Boolean ! hasPreviousPage : Boolean ! startCursor : String } \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Account`\"\"\" accountCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : AccountFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [AccountOrderBy ! ] ) : AccountConnection \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogOrderBy ! ] ) : BlogConnection \"\"\"A pagable collection of type `BlogPost`\"\"\" blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [BlogPostOrderBy ! ] ) : BlogPostConnection } \"\"\" Boolean expression comparing fields on type \" String \" \"\"\" input StringFilter { eq : String gt : String gte : String lt : String lte : String neq : String } scalar UUID \"\"\" Boolean expression comparing fields on type \" UUID \" \"\"\" input UUIDFilter { eq : UUID neq : UUID }","title":"Example"}]}