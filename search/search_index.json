{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pg_graphql Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql Query your existing PostgreSQL database with GraphQL pg_graphql inspects your PostgreSQL schema and reflects a GraphQL schema with resolvers. Performant : +2k requests/second Always up-to-date : Reflected from the SQL schema Pagination : Relay compliant Serverless : Runs in your database with no additional server required Open Source : Apache License 2.0 Warning pg_graphql is pre-alpha software under active development Motivation pg_graphql provides an SQL schema -> GraphQL schema reflection engine and an associated GraphQL query -> SQL query transpiler. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries. TL;DR The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema exposing each table as a pageable collection with relationships defined by the foreign keys.","title":"Welcome"},{"location":"#pg_graphql","text":"Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql Query your existing PostgreSQL database with GraphQL pg_graphql inspects your PostgreSQL schema and reflects a GraphQL schema with resolvers. Performant : +2k requests/second Always up-to-date : Reflected from the SQL schema Pagination : Relay compliant Serverless : Runs in your database with no additional server required Open Source : Apache License 2.0 Warning pg_graphql is pre-alpha software under active development","title":"pg_graphql"},{"location":"#motivation","text":"pg_graphql provides an SQL schema -> GraphQL schema reflection engine and an associated GraphQL query -> SQL query transpiler. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries.","title":"Motivation"},{"location":"#tldr","text":"The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema exposing each table as a pageable collection with relationships defined by the foreign keys.","title":"TL;DR"},{"location":"api/","text":"The public API consists of a single function to resolve GraphQL queries. All other entities in the graphql schema are private. graphql.resolve description Resolves a GraphQL query, returning JSONB. signature 1 2 3 4 5 6 7 8 9 10 11 12 graphql . resolve ( -- the graphql query/mutation stmt text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , ) returns jsonb strict volatile parallel safe language plpgsql usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- Setup graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Example graphqldb = select graphql . resolve ( $$ query { allBooks { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"allBooks\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"API"},{"location":"api/#graphqlresolve","text":"","title":"graphql.resolve"},{"location":"api/#description","text":"Resolves a GraphQL query, returning JSONB.","title":"description"},{"location":"api/#signature","text":"1 2 3 4 5 6 7 8 9 10 11 12 graphql . resolve ( -- the graphql query/mutation stmt text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , ) returns jsonb strict volatile parallel safe language plpgsql","title":"signature"},{"location":"api/#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- Setup graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Example graphqldb = select graphql . resolve ( $$ query { allBooks { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"allBooks\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"usage"},{"location":"configuration/","text":"Table/Column Visibility Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL permissions. Revoking SELECT access from the user/role executing queries removes that entity from the schema. For example: 1 revoke all privileges on public . account from api_user ; removes the Account GraphQL type. Names Name configuration is a planned goal but not currently implemented. The ability to: Override type names Override field names are planned for future releases","title":"Configuration"},{"location":"configuration/#tablecolumn-visibility","text":"Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL permissions. Revoking SELECT access from the user/role executing queries removes that entity from the schema. For example: 1 revoke all privileges on public . account from api_user ; removes the Account GraphQL type.","title":"Table/Column Visibility"},{"location":"configuration/#names","text":"Name configuration is a planned goal but not currently implemented. The ability to: Override type names Override field names are planned for future releases","title":"Names"},{"location":"contributing/","text":"pg_graphql is OSS. PR and issues are welcome. Development Nix is required to set up the environment. Testing Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 2 # might take a few minutes downloading dependencies on the first run $ nix-shell --run \"pg_13_graphql make installcheck\" Interactive PSQL Development To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 nix-shell --run \"pg_13_graphql psql\" Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { allBooks { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"allBooks\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] } Documentation All public API must be documented. Building documentation requires python 3.6+ Install Dependencies Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt Serving To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Contributing"},{"location":"contributing/#development","text":"Nix is required to set up the environment.","title":"Development"},{"location":"contributing/#testing","text":"Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 2 # might take a few minutes downloading dependencies on the first run $ nix-shell --run \"pg_13_graphql make installcheck\"","title":"Testing"},{"location":"contributing/#interactive-psql-development","text":"To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 nix-shell --run \"pg_13_graphql psql\" Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { allBooks { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"allBooks\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"Interactive PSQL Development"},{"location":"contributing/#documentation","text":"All public API must be documented. Building documentation requires python 3.6+","title":"Documentation"},{"location":"contributing/#install-dependencies","text":"Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt","title":"Install Dependencies"},{"location":"contributing/#serving","text":"To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Serving"},{"location":"installation/","text":"Tested with PostgreSQL 13. Direct Server Access First, install libgraphqlparser Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql make install To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql cascade ; Hosted Databases e.g. RDS, Cloud SQL Hosted database vendors do not provide the level of server access required to install pg_graphql at this time. Given that third-party hosted databases are increasingly common, we are exploring including SQL implementations of pg_graphql 's C components so it can be installed as a single-file SQL script. Stay tuned","title":"Installation"},{"location":"installation/#direct-server-access","text":"First, install libgraphqlparser Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql make install To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql cascade ;","title":"Direct Server Access"},{"location":"installation/#hosted-databases-eg-rds-cloud-sql","text":"Hosted database vendors do not provide the level of server access required to install pg_graphql at this time. Given that third-party hosted databases are increasingly common, we are exploring including SQL implementations of pg_graphql 's C components so it can be installed as a single-file SQL script. Stay tuned","title":"Hosted Databases e.g. RDS, Cloud SQL"},{"location":"performance/","text":"On an a machine with: 4 CPUs 16GB of RAM PostgreSQL 13 (docker) Postgrest +8 (docker, operating as webserver) pg_graphql served a simple query at an average rate of +2200 req/second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 This is ApacheBench, Version 2.3 <$Revision: 1843412 $> Benchmarking 0.0.0.0 (be patient) Finished 8000 requests Server Software: postgrest/8.0.0 Server Hostname: 0.0.0.0 Server Port: 3000 Document Path: /rpc/graphql Document Length: 46 bytes Concurrency Level: 8 Time taken for tests: 3.628 seconds Complete requests: 8000 Failed requests: 0 Total transferred: 1768000 bytes Total body sent: 1928000 HTML transferred: 368000 bytes Requests per second: 2205.21 [#/sec] (mean) Time per request: 3.628 [ms] (mean) Time per request: 0.453 [ms] (mean, across all concurrent requests) Transfer rate: 475.93 [Kbytes/sec] received 519.00 kb/s sent 994.93 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 1 4 3.7 2 39 Waiting: 0 3 3.6 2 39 Total: 1 4 3.7 2 39 Percentage of the requests served within a certain time (ms) 50% 2 66% 3 75% 3 80% 4 90% 7 95% 10 98% 15 99% 22 100% 39 (longest request) To reproduce this result, start the demo described in the quickstart guide and apache bench on a sample query. i.e. 1 2 3 4 5 docker-compose up echo '{\"query\": \"{ account(nodeId: $nodeId) { id }}\", \"variables\": {\"nodeId\": \"WyJhY2NvdW50IiwgMV0=\"}}' > query.json ab -n 8000 -c 8 -T application/json -p query.json http://0.0.0.0:3000/rpc/graphql","title":"Performance"},{"location":"quickstart/","text":"If you are new to the project, start here. The easiest way to try pg_graphql is to run the interactive GraphiQL IDE demo. The demo environment launches a database, webserver and the GraphiQL IDE/API explorer with a small pre-populated schema. Requires: git docker-compose First, clone the repo 1 2 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql Next, launch the demo with docker-compose. 1 docker-compose up Finally, access GraphiQL at http://localhost:4000/ .","title":"Quickstart"},{"location":"reflection/","text":"SQL tables are reflected into GraphQL types with columns and foreign keys represented as fields on those types. Each table's GraphQL types are then registered against the top level Query type enabling selection of a record by its globally unique ID, or paging through all of the rows in a table. Naming PostgreSQL tables/columns are are expected to be lowercase with underscores. To follow casing conventions, table and column are converted to pascal case for type name, camel case for field names and pluralized as necessary in the GraphQL schema. For example, an account table has GraphQL type name Account and fields on the Query type of account and allAccounts . The pluralization logic is extremely basic. Name overrides have not been implemented yet but are comming soon. Type Conversion ID The \"ID\" GraphQL type is a globally unique identifer. It is represented as a string and is implemented as a base64 encoded json array of [regclass, pkey_value1, ... pkey_valueN] . Warning Be careful when adding/removing schemas from the PostgreSQL search_path as these impact the string representation for regclass and will cause the global identifer to change. Connection Types Connection types hande pagination best practices according to the relay spec . pg_graphql paginates via keyset pagination to enable consistent retrival times on every page. Cursor See relay documentation A cursor is custom scalar, represented as an opaque string, that is used for pagination. Its implementation is identical to the ID type but that is an implementation detail and should not be relied upon. PageInfo See relay documentation PostgreSQL Builtins PostgreSQL GraphQL bool Boolean float4 Float float8 Float int2 Int int4 Int int8 Int json JSON jsonb JSON jsonpath String numeric Float date DateTime daterange String timestamp DateTime timestamptz DateTime uuid UUID text String char String inet InternetAddress inet InternetAddress macaddr MACAddress other String Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 scalar Cursor scalar DateTime scalar JSON scalar UUID scalar BigInt type Query { account(nodeId: ID!): Account allAccounts(after: Cursor, before: Cursor, first: Int, last: Int): AccountConnection blog(nodeId: ID!): Blog allBlogs(after: Cursor, before: Cursor, first: Int, last: Int): BlogConnection blogPost(nodeId: ID!): BlogPost allBlogPosts(after: Cursor, before: Cursor, first: Int, last: Int): BlogPostConnection } type Account { nodeId: ID! id: String! email: String! encryptedPassword: String! createdAt: DateTime! updatedAt: DateTime! blogs(after: Cursor, before: Cursor, first: Int, last: Int): BlogConnection } type AccountConnection { edges: [AccountEdge] pageInfo: PageInfo! totalCount: Int! } type AccountEdge { node: Account cursor: String! } type Blog { nodeId: ID! id: String! ownerId: String! name: String! description: String createdAt: DateTime! updatedAt: DateTime! owner: Account blogPosts(after: Cursor, before: Cursor, first: Int, last: Int): BlogPostConnection } type BlogConnection { edges: [BlogEdge] pageInfo: PageInfo! totalCount: Int! } type BlogEdge { node: Blog cursor: String! } type BlogPost { nodeId: ID! id: UUID! blogId: String! title: String! body: String status: String! createdAt: DateTime! updatedAt: DateTime! blog: Blog } type BlogPostConnection { edges: [BlogPostEdge] pageInfo: PageInfo! totalCount: Int! } type BlogPostEdge { node: BlogPost cursor: String! } enum BlogPostStatus { PENDING RELEASED } type PageInfo { hasPreviousPage: Boolean! hasNextPage: Boolean! startCursor: String! endCursor: String! }","title":"Reflection"},{"location":"reflection/#naming","text":"PostgreSQL tables/columns are are expected to be lowercase with underscores. To follow casing conventions, table and column are converted to pascal case for type name, camel case for field names and pluralized as necessary in the GraphQL schema. For example, an account table has GraphQL type name Account and fields on the Query type of account and allAccounts . The pluralization logic is extremely basic. Name overrides have not been implemented yet but are comming soon.","title":"Naming"},{"location":"reflection/#type-conversion","text":"","title":"Type Conversion"},{"location":"reflection/#id","text":"The \"ID\" GraphQL type is a globally unique identifer. It is represented as a string and is implemented as a base64 encoded json array of [regclass, pkey_value1, ... pkey_valueN] . Warning Be careful when adding/removing schemas from the PostgreSQL search_path as these impact the string representation for regclass and will cause the global identifer to change.","title":"ID"},{"location":"reflection/#connection-types","text":"Connection types hande pagination best practices according to the relay spec . pg_graphql paginates via keyset pagination to enable consistent retrival times on every page.","title":"Connection Types"},{"location":"reflection/#cursor","text":"See relay documentation A cursor is custom scalar, represented as an opaque string, that is used for pagination. Its implementation is identical to the ID type but that is an implementation detail and should not be relied upon.","title":"Cursor"},{"location":"reflection/#pageinfo","text":"See relay documentation","title":"PageInfo"},{"location":"reflection/#postgresql-builtins","text":"PostgreSQL GraphQL bool Boolean float4 Float float8 Float int2 Int int4 Int int8 Int json JSON jsonb JSON jsonpath String numeric Float date DateTime daterange String timestamp DateTime timestamptz DateTime uuid UUID text String char String inet InternetAddress inet InternetAddress macaddr MACAddress other String","title":"PostgreSQL Builtins"},{"location":"reflection/#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 scalar Cursor scalar DateTime scalar JSON scalar UUID scalar BigInt type Query { account(nodeId: ID!): Account allAccounts(after: Cursor, before: Cursor, first: Int, last: Int): AccountConnection blog(nodeId: ID!): Blog allBlogs(after: Cursor, before: Cursor, first: Int, last: Int): BlogConnection blogPost(nodeId: ID!): BlogPost allBlogPosts(after: Cursor, before: Cursor, first: Int, last: Int): BlogPostConnection } type Account { nodeId: ID! id: String! email: String! encryptedPassword: String! createdAt: DateTime! updatedAt: DateTime! blogs(after: Cursor, before: Cursor, first: Int, last: Int): BlogConnection } type AccountConnection { edges: [AccountEdge] pageInfo: PageInfo! totalCount: Int! } type AccountEdge { node: Account cursor: String! } type Blog { nodeId: ID! id: String! ownerId: String! name: String! description: String createdAt: DateTime! updatedAt: DateTime! owner: Account blogPosts(after: Cursor, before: Cursor, first: Int, last: Int): BlogPostConnection } type BlogConnection { edges: [BlogEdge] pageInfo: PageInfo! totalCount: Int! } type BlogEdge { node: Blog cursor: String! } type BlogPost { nodeId: ID! id: UUID! blogId: String! title: String! body: String status: String! createdAt: DateTime! updatedAt: DateTime! blog: Blog } type BlogPostConnection { edges: [BlogPostEdge] pageInfo: PageInfo! totalCount: Int! } type BlogPostEdge { node: BlogPost cursor: String! } enum BlogPostStatus { PENDING RELEASED } type PageInfo { hasPreviousPage: Boolean! hasNextPage: Boolean! startCursor: String! endCursor: String! }","title":"Example"},{"location":"roadmap/","text":"pg_graphql aims to implement all of the GraphQL core specification and as much of the relay server specification as is practical. Language Parser Fragments Variables Named Operations Introspection Schema At time of writing, the introspection schema is a partial implementation. It is complete enough to render the GraphiQL explorer & to dump the schema via the Apollo CLI. Relay Opaque Cursors Global NodeId Node Types Arguments nodeId Connection Types totalCount PageInfo hasNextPage hasPreviousPage startCursor endCursor Edges cursor Pagination Arguments first last before after condition Relationships One-to-Many Many-to-Many Many-to-One One-to-One Mutations Upsert User Defined Functions Error Handling Display parser syntax errors Useful error on non-existent field Configuration Max Query Depth Document Role based schema/table/column exclusion Override Type/Field names Optimizations Prepared statement query cached","title":"Roadmap"},{"location":"roadmap/#language","text":"Parser Fragments Variables Named Operations Introspection Schema At time of writing, the introspection schema is a partial implementation. It is complete enough to render the GraphiQL explorer & to dump the schema via the Apollo CLI.","title":"Language"},{"location":"roadmap/#relay","text":"Opaque Cursors Global NodeId Node Types Arguments nodeId Connection Types totalCount PageInfo hasNextPage hasPreviousPage startCursor endCursor Edges cursor Pagination Arguments first last before after condition","title":"Relay"},{"location":"roadmap/#relationships","text":"One-to-Many Many-to-Many Many-to-One One-to-One","title":"Relationships"},{"location":"roadmap/#mutations","text":"Upsert User Defined Functions","title":"Mutations"},{"location":"roadmap/#error-handling","text":"Display parser syntax errors Useful error on non-existent field","title":"Error Handling"},{"location":"roadmap/#configuration","text":"Max Query Depth Document Role based schema/table/column exclusion Override Type/Field names","title":"Configuration"},{"location":"roadmap/#optimizations","text":"Prepared statement query cached","title":"Optimizations"}]}